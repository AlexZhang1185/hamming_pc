commit ccedf66b65f6ab245aa6028d7fe9eb603a121b43
Author: Emil Velikov <emil.l.velikov@gmail.com>
Date:   Wed Sep 9 16:02:18 2015 +0100

    xf86drm: add drm{Get,Free}Device
    
    Similar interface to the *Devices() ones but they obtain/free the
    information of the opened device (as given by its fd).
    
    Note there is a fair bit of duplication between the two Get functions,
    and anyone interested is more than welcome to consolidate it.
    
    Signed-off-by: Emil Velikov <emil.l.velikov@gmail.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/xf86drm.h b/xf86drm.h
index e82ca84..481d882 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -790,6 +790,9 @@ typedef struct _drmDevice {
     } deviceinfo;
 } drmDevice, *drmDevicePtr;
 
+extern int drmGetDevice(int fd, drmDevicePtr *device);
+extern void drmFreeDevice(drmDevicePtr *device);
+
 extern int drmGetDevices(drmDevicePtr devices[], int max_devices);
 extern void drmFreeDevices(drmDevicePtr devices[], int count);
 

commit b556ea127e004b734b2a7bf8e67cdcf56312171d
Author: Emil Velikov <emil.l.velikov@gmail.com>
Date:   Mon Aug 17 11:09:06 2015 +0800

    drm: add interface to get drm devices on the system v3
    
    For mutiple GPU support, the devices on the system should be enumerated
    to get necessary information about each device, and the drmGetDevices
    interface is added for this. Currently only PCI devices are supported for
    the enumeration.
    
    Typical usage:
    int count;
    drmDevicePtr *foo;
    count = drmGetDevices(NULL, 0);
    foo = calloc(count, sizeof(drmDevicePtr));
    count = drmGetDevices(foo, count);
    /* find proper device, open correct device node, etc */
    drmFreeDevices(foo, count);
    free(foo);
    
    v2: [Jammy Zhou]
     - return a list of devices, rather than nodes
    v3: [Jammy Zhou]
     - fix the signed extension for PCI device info
    
    Signed-off-by: Emil Velikov <emil.l.velikov@gmail.com>
    Signed-off-by: Jammy Zhou <Jammy.Zhou@amd.com>

diff --git a/xf86drm.h b/xf86drm.h
index 360e04a..e82ca84 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -563,6 +563,8 @@ extern int           drmOpen(const char *name, const char *busid);
 #define DRM_NODE_PRIMARY 0
 #define DRM_NODE_CONTROL 1
 #define DRM_NODE_RENDER  2
+#define DRM_NODE_MAX     3
+
 extern int           drmOpenWithType(const char *name, const char *busid,
                                      int type);
 
@@ -759,6 +761,38 @@ extern int drmPrimeFDToHandle(int fd, int prime_fd, uint32_t *handle);
 extern char *drmGetPrimaryDeviceNameFromFd(int fd);
 extern char *drmGetRenderDeviceNameFromFd(int fd);
 
+#define DRM_BUS_PCI   0
+
+typedef struct _drmPciBusInfo {
+    uint16_t domain;
+    uint8_t bus;
+    uint8_t dev;
+    uint8_t func;
+} drmPciBusInfo, *drmPciBusInfoPtr;
+
+typedef struct _drmPciDeviceInfo {
+    uint16_t vendor_id;
+    uint16_t device_id;
+    uint16_t subvendor_id;
+    uint16_t subdevice_id;
+    uint8_t revision_id;
+} drmPciDeviceInfo, *drmPciDeviceInfoPtr;
+
+typedef struct _drmDevice {
+    char **nodes; /* DRM_NODE_MAX sized array */
+    int available_nodes; /* DRM_NODE_* bitmask */
+    int bustype;
+    union {
+        drmPciBusInfoPtr pci;
+    } businfo;
+    union {
+        drmPciDeviceInfoPtr pci;
+    } deviceinfo;
+} drmDevice, *drmDevicePtr;
+
+extern int drmGetDevices(drmDevicePtr devices[], int max_devices);
+extern void drmFreeDevices(drmDevicePtr devices[], int count);
+
 #if defined(__cplusplus)
 }
 #endif

commit 1c205749fe2171aaa69ce053a8f248e329bd72f7
Author: Tapani Pälli <tapani.palli@intel.com>
Date:   Fri Aug 7 10:37:56 2015 +0300

    remove usage of 'c_plusplus' preprocessor macro
    
    Use only __cplusplus which is supported by the C++ standard.
    
    Signed-off-by: Tapani Pälli <tapani.palli@intel.com>
    Reviewed-by: Emil Velikov <emil.l.velikov@gmail.com>

diff --git a/xf86drm.h b/xf86drm.h
index e3a19dc..360e04a 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -39,7 +39,7 @@
 #include <stdint.h>
 #include <drm.h>
 
-#if defined(__cplusplus) || defined(c_plusplus)
+#if defined(__cplusplus)
 extern "C" {
 #endif
 
@@ -759,7 +759,7 @@ extern int drmPrimeFDToHandle(int fd, int prime_fd, uint32_t *handle);
 extern char *drmGetPrimaryDeviceNameFromFd(int fd);
 extern char *drmGetRenderDeviceNameFromFd(int fd);
 
-#if defined(__cplusplus) || defined(c_plusplus)
+#if defined(__cplusplus)
 }
 #endif
 

commit fc083322b0c8a58b51976adf23a582bce8bb75f1
Author: Jonathan Gray <jsg@jsg.id.au>
Date:   Tue Jul 21 03:12:56 2015 +1000

    xf86drm: use the correct device minor names on OpenBSD
    
    Add defines for the device minor names and make use of them
    in drmGetMinorName() so the correct paths will be used on OpenBSD.
    
    v2: don't add new defines to xf86drm.h to keep them out of the API
        as requested by Emil.
    
    Signed-off-by: Jonathan Gray <jsg@jsg.id.au>
    Reviewed-by: Emil Velikov <emil.l.velikov@gmail.com>

diff --git a/xf86drm.h b/xf86drm.h
index 40c55c9..e3a19dc 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -76,11 +76,18 @@ extern "C" {
 	(S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH)
 #define DRM_DEV_MODE	 (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP)
 
+#ifdef __OpenBSD__
+#define DRM_DIR_NAME  "/dev"
+#define DRM_DEV_NAME  "%s/drm%d"
+#define DRM_CONTROL_DEV_NAME  "%s/drmC%d"
+#define DRM_RENDER_DEV_NAME  "%s/drmR%d"
+#else
 #define DRM_DIR_NAME  "/dev/dri"
 #define DRM_DEV_NAME  "%s/card%d"
 #define DRM_CONTROL_DEV_NAME  "%s/controlD%d"
 #define DRM_RENDER_DEV_NAME  "%s/renderD%d"
 #define DRM_PROC_NAME "/proc/dri/" /* For backward Linux compatibility */
+#endif
 
 #define DRM_ERR_NO_DEVICE  (-1001)
 #define DRM_ERR_NO_ACCESS  (-1002)

commit 5b0e76f143887c4ec7db45c54a7ba27a58f59227
Author: Emil Velikov <emil.l.velikov@gmail.com>
Date:   Sat May 30 14:25:08 2015 +0100

    Revert "Add device enumeration interface (v4)"
    
    This reverts commit fde4969176822fe54197b6baa78f8b0ef900baba.
    
    The commit adds an API that does not seem flexible enough to be used in
    current open-source projects. Additionally it adds a hidden dependency
    of libudev, which when used in mesa caused grief when combined with
    Steam('s runtime).
    
    Let's revert this for now and add a tweaked API later on that can be
    used in mesa/xserver.
    
    Cc: Frank Min <frank.min@amd.com>
    Cc: Christian König <christian.koenig@amd.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Jammy Zhou <Jammy.Zhou@amd.com>

diff --git a/xf86drm.h b/xf86drm.h
index 2610934..40c55c9 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -342,24 +342,6 @@ typedef struct _drmSetVersion {
 	int drm_dd_minor;
 } drmSetVersion, *drmSetVersionPtr;
 
-/**
- * Structure to a general pci gpu device
- *
- * \sa drmGetDevices()
- *
-*/
-typedef struct _drmPciDevice {
-		uint16_t domain;
-		uint8_t bus;
-		uint8_t dev;
-		uint8_t func;
-		uint16_t vendor_id;
-		uint16_t device_id;
-		uint16_t subvendor_id;
-		uint16_t subdevice_id;
-		uint8_t revision_id;
-} drmPciDevice, *drmPciDevicePtr;
-
 #define __drm_dummy_lock(lock) (*(__volatile__ unsigned int *)lock)
 
 #define DRM_LOCK_HELD  0x80000000U /**< Hardware lock is held */
@@ -570,7 +552,6 @@ do {	register unsigned int __old __asm("o0");		\
 /* General user-level programmer's API: unprivileged */
 extern int           drmAvailable(void);
 extern int           drmOpen(const char *name, const char *busid);
-extern int           drmGetPciDevices(drmPciDevicePtr devSet, uint16_t vendorId);
 
 #define DRM_NODE_PRIMARY 0
 #define DRM_NODE_CONTROL 1

commit fde4969176822fe54197b6baa78f8b0ef900baba
Author: frank <frank.min@amd.com>
Date:   Tue May 19 23:31:05 2015 +0800

    Add device enumeration interface (v4)
    
    Add an interface for enumerating PCI devices on
    a system.
    
    v3: switch to udev/sysfs for the enumeration
    v4: fix warnings
    
    Signed-off-by: Frank Min <frank.min@amd.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Jammy Zhou <Jammy.Zhou@amd.com>

diff --git a/xf86drm.h b/xf86drm.h
index 40c55c9..2610934 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -342,6 +342,24 @@ typedef struct _drmSetVersion {
 	int drm_dd_minor;
 } drmSetVersion, *drmSetVersionPtr;
 
+/**
+ * Structure to a general pci gpu device
+ *
+ * \sa drmGetDevices()
+ *
+*/
+typedef struct _drmPciDevice {
+		uint16_t domain;
+		uint8_t bus;
+		uint8_t dev;
+		uint8_t func;
+		uint16_t vendor_id;
+		uint16_t device_id;
+		uint16_t subvendor_id;
+		uint16_t subdevice_id;
+		uint8_t revision_id;
+} drmPciDevice, *drmPciDevicePtr;
+
 #define __drm_dummy_lock(lock) (*(__volatile__ unsigned int *)lock)
 
 #define DRM_LOCK_HELD  0x80000000U /**< Hardware lock is held */
@@ -552,6 +570,7 @@ do {	register unsigned int __old __asm("o0");		\
 /* General user-level programmer's API: unprivileged */
 extern int           drmAvailable(void);
 extern int           drmOpen(const char *name, const char *busid);
+extern int           drmGetPciDevices(drmPciDevicePtr devSet, uint16_t vendorId);
 
 #define DRM_NODE_PRIMARY 0
 #define DRM_NODE_CONTROL 1

commit 0ca03a4087a550646de7f26b6b53a932e8546474
Author: Emil Velikov <emil.l.velikov@gmail.com>
Date:   Sat Mar 7 00:58:39 2015 +0000

    drm: add drmGet(Primary|Render)DeviceNameFromFd functions
    
    Currently most places assume reliable primary(master) <> render node
    mapping. Although this may work in some cases, it is not correct.
    
    Add a couple of helpers that hide the details and provide the name of
    the master or render device name, given an fd. The latter may belong to
    either the master, control or render node device.
    
    v2:
     - Rename Device and Primary to Master (aka the /dev/dri/cardX device).
     - Check for the file via readdir_r() rather than stat().
     - Wrap the check into a single function.
     - Return NULL for non-linux platforms.
    
    v3:
     - Don't segfault if name is NULL.
     - Update function names, as suggested by Frank Binns.
    
    v4:
     - Update commit message to reflect the function name changes.
    
    Cc: Frank Binns <frank.binns@imgtec.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: David Herrmann <dh.herrmann@googlemail.com>
    Signed-off-by: Emil Velikov <emil.l.velikov@gmail.com>
    Reviewed-by: Frank Binns <frank.binns@imgtec.com>

diff --git a/xf86drm.h b/xf86drm.h
index afd38a1..40c55c9 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -749,6 +749,9 @@ extern int drmGetNodeTypeFromFd(int fd);
 extern int drmPrimeHandleToFD(int fd, uint32_t handle, uint32_t flags, int *prime_fd);
 extern int drmPrimeFDToHandle(int fd, int prime_fd, uint32_t *handle);
 
+extern char *drmGetPrimaryDeviceNameFromFd(int fd);
+extern char *drmGetRenderDeviceNameFromFd(int fd);
+
 #if defined(__cplusplus) || defined(c_plusplus)
 }
 #endif

commit 1f73578df32f895a678a41758f6c563f49484347
Author: Frank Binns <frank.binns@imgtec.com>
Date:   Fri Feb 13 10:51:15 2015 +0000

    Add new drmGetNodeTypeFromFd function
    
    Add a helper function that returns the type of device node from an fd.
    
    Signed-off-by: Frank Binns <frank.binns@imgtec.com>
    Reviewed-by: Emil Velikov <emil.l.velikov@gmail.com>

diff --git a/xf86drm.h b/xf86drm.h
index 77937eb..afd38a1 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -744,6 +744,7 @@ typedef struct _drmEventContext {
 extern int drmHandleEvent(int fd, drmEventContextPtr evctx);
 
 extern char *drmGetDeviceNameFromFd(int fd);
+extern int drmGetNodeTypeFromFd(int fd);
 
 extern int drmPrimeHandleToFD(int fd, uint32_t handle, uint32_t flags, int *prime_fd);
 extern int drmPrimeFDToHandle(int fd, int prime_fd, uint32_t *handle);

commit dbc8b11db6f3fcbe2a76487bb0b1930908226a17
Author: Jammy Zhou <Jammy.Zhou@amd.com>
Date:   Mon Feb 2 18:06:27 2015 +0800

    Add new drmOpenOnceWithType function (v2)
    
    v2: call drmOpenOnceWithType in drmOpenOnce, and drop unused param
    for drmOpenOnceWithType
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Jammy Zhou <Jammy.Zhou@amd.com>

diff --git a/xf86drm.h b/xf86drm.h
index 7e82521..77937eb 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -712,6 +712,7 @@ extern int  drmSLLookupNeighbors(void *l, unsigned long key,
 				 unsigned long *next_key, void **next_value);
 
 extern int drmOpenOnce(void *unused, const char *BusID, int *newlyopened);
+extern int drmOpenOnceWithType(const char *BusID, int *newlyopened, int type);
 extern void drmCloseOnce(int fd);
 extern void drmMsg(const char *format, ...) DRM_PRINTFLIKE(1, 2);
 

commit f1adc4b375a16b07f560b86a34e617984049c422
Author: Jammy Zhou <Jammy.Zhou@amd.com>
Date:   Wed Feb 11 12:40:51 2015 +0800

    Add new drmOpenWithType function (v4)
    
    v2: Add drmGetMinorBase, and call drmOpenWithType in drmOpen
    v3: Pass 'type' to drmOpenByBusid and drmOpenDevice in drmOpenByName
    v4: Renumber node type definitions, and return -1 for unsupported type
    
    Signed-off-by: Jammy Zhou <Jammy.Zhou@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com> (v3)
    Reviewed-by: Frank Binns <frank.binns@imgtec.com>

diff --git a/xf86drm.h b/xf86drm.h
index bfd0670..7e82521 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -552,7 +552,14 @@ do {	register unsigned int __old __asm("o0");		\
 /* General user-level programmer's API: unprivileged */
 extern int           drmAvailable(void);
 extern int           drmOpen(const char *name, const char *busid);
-extern int drmOpenControl(int minor);
+
+#define DRM_NODE_PRIMARY 0
+#define DRM_NODE_CONTROL 1
+#define DRM_NODE_RENDER  2
+extern int           drmOpenWithType(const char *name, const char *busid,
+                                     int type);
+
+extern int           drmOpenControl(int minor);
 extern int           drmOpenRender(int minor);
 extern int           drmClose(int fd);
 extern drmVersionPtr drmGetVersion(int fd);

commit 0c5aaeef51233aec89ee1f43f03d457f278f8fa0
Author: Frank Binns <frank.binns@imgtec.com>
Date:   Wed Jan 14 14:07:51 2015 +0000

    Add new drmOpenRender function
    
    Add a new function, drmOpenRender, that can be used to open render nodes. This
    can be used in the same way that drmOpenControl is used to open control nodes.
    
    Signed-off-by: Frank Binns <frank.binns@imgtec.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>

diff --git a/xf86drm.h b/xf86drm.h
index c024cc4..bfd0670 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -79,6 +79,7 @@ extern "C" {
 #define DRM_DIR_NAME  "/dev/dri"
 #define DRM_DEV_NAME  "%s/card%d"
 #define DRM_CONTROL_DEV_NAME  "%s/controlD%d"
+#define DRM_RENDER_DEV_NAME  "%s/renderD%d"
 #define DRM_PROC_NAME "/proc/dri/" /* For backward Linux compatibility */
 
 #define DRM_ERR_NO_DEVICE  (-1001)
@@ -552,6 +553,7 @@ do {	register unsigned int __old __asm("o0");		\
 extern int           drmAvailable(void);
 extern int           drmOpen(const char *name, const char *busid);
 extern int drmOpenControl(int minor);
+extern int           drmOpenRender(int minor);
 extern int           drmClose(int fd);
 extern drmVersionPtr drmGetVersion(int fd);
 extern drmVersionPtr drmGetLibVersion(int fd);

commit 44b08c0ddf7ced99a5914421f18b269a1dcaafae
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Jan 22 12:06:51 2014 +0100

    Mark functions printf-like where possible
    
    These functions all take a format string and either a list of variable
    arguments or a va_list. Use the new DRM_PRINTFLIKE macro to tell the
    compiler about it so that the arguments can be checked against the
    format string.
    
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/xf86drm.h b/xf86drm.h
index 5e170f8..c024cc4 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -704,7 +704,7 @@ extern int  drmSLLookupNeighbors(void *l, unsigned long key,
 
 extern int drmOpenOnce(void *unused, const char *BusID, int *newlyopened);
 extern void drmCloseOnce(int fd);
-extern void drmMsg(const char *format, ...);
+extern void drmMsg(const char *format, ...) DRM_PRINTFLIKE(1, 2);
 
 extern int drmSetMaster(int fd);
 extern int drmDropMaster(int fd);

commit cb4bc8ead63cb213a26bcc8d14b2b44d9fb967da
Author: Keith Packard <keithp@keithp.com>
Date:   Sun Jan 12 10:32:57 2014 -0800

    Mark debug_print with __attribute__ ((format(__printf__, 1, 0)))
    
    the drmServerInfo member, debug_print, takes a printf format string
    and varargs list. Tell the compiler about it.
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Reviewed-by: Ian Romanick <ian.d.romanick@intel.com>

diff --git a/xf86drm.h b/xf86drm.h
index 1e763a3..5e170f8 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -92,8 +92,14 @@ extern "C" {
 typedef unsigned int  drmSize,     *drmSizePtr;	    /**< For mapped regions */
 typedef void          *drmAddress, **drmAddressPtr; /**< For mapped regions */
 
+#if (__GNUC__ >= 3)
+#define DRM_PRINTFLIKE(f, a) __attribute__ ((format(__printf__, f, a)))
+#else
+#define DRM_PRINTFLIKE(f, a)
+#endif
+
 typedef struct _drmServerInfo {
-  int (*debug_print)(const char *format, va_list ap);
+  int (*debug_print)(const char *format, va_list ap) DRM_PRINTFLIKE(1,0);
   int (*load_module)(const char *name);
   void (*get_perms)(gid_t *, mode_t *);
 } drmServerInfo, *drmServerInfoPtr;

commit ddbbdb13d80ea7f60e6f71356a444995b905366b
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Tue Sep 3 15:34:41 2013 +0100

    drm: Introduce a drmSetClientCap() wrapper
    
    That wraps around the new DRM_SET_CLIENT_CAP ioctl.
    
    v2: SET_CAP -> SET_CLIENT_CAP renaming
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>

diff --git a/xf86drm.h b/xf86drm.h
index 5ecb284..1e763a3 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -609,6 +609,8 @@ extern int           drmUpdateDrawableInfo(int fd, drm_drawable_t handle,
 					   unsigned int num, void *data);
 extern int           drmCtlInstHandler(int fd, int irq);
 extern int           drmCtlUninstHandler(int fd);
+extern int           drmSetClientCap(int fd, uint64_t capability,
+				     uint64_t value);
 
 /* General user-level programmer's API: authenticated client and/or X */
 extern int           drmMap(int fd,

commit cc0a14575d9fd0aafe73cb4aa445eaf024436114
Author: Dave Airlie <airlied@gmail.com>
Date:   Sat Jul 14 09:52:17 2012 +0000

    libdrm: add prime fd->handle and handle->fd interfaces
    
    These are just basic ioctl wrappers around the prime ioctls,
    along with the capability reporting.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/xf86drm.h b/xf86drm.h
index 76eb94e..5ecb284 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -727,6 +727,9 @@ extern int drmHandleEvent(int fd, drmEventContextPtr evctx);
 
 extern char *drmGetDeviceNameFromFd(int fd);
 
+extern int drmPrimeHandleToFD(int fd, uint32_t handle, uint32_t flags, int *prime_fd);
+extern int drmPrimeFDToHandle(int fd, int prime_fd, uint32_t *handle);
+
 #if defined(__cplusplus) || defined(c_plusplus)
 }
 #endif

commit cfee5218b17a2741e5519ed44091171e01f0dbb2
Author: Tapani Pälli <tapani.palli@intel.com>
Date:   Fri Sep 23 14:17:42 2011 +0300

    xf86drm.h : wrap C code for C++ compilation/linking
    
    To enable usage of xf86drm.h from C++ programs/frameworks.
    
    Signed-off-by: Tapani Pälli <tapani.palli@intel.com>
    [ickle: also wrap xf86drmMode.h]
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/xf86drm.h b/xf86drm.h
index 20f4c78..76eb94e 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -39,6 +39,10 @@
 #include <stdint.h>
 #include <drm.h>
 
+#if defined(__cplusplus) || defined(c_plusplus)
+extern "C" {
+#endif
+
 #ifndef DRM_MAX_MINOR
 #define DRM_MAX_MINOR   16
 #endif
@@ -723,4 +727,8 @@ extern int drmHandleEvent(int fd, drmEventContextPtr evctx);
 
 extern char *drmGetDeviceNameFromFd(int fd);
 
+#if defined(__cplusplus) || defined(c_plusplus)
+}
+#endif
+
 #endif

commit be8802a9414e85ba07ae257fccadd245fcf7c7b6
Author: Ilija Hadzic <ihadzic@research.bell-labs.com>
Date:   Thu Mar 24 13:24:28 2011 -0400

    libdrm: (revised) vblank wait on crtc > 1
    
    Hi Alex,
    
    Enclosed is a revised version of the patch sent on Mar 18, against
    the master branch of the drm userspace (i.e. libdrm). Details
    summarised in this thread:
    http://lists.freedesktop.org/archives/dri-devel/2011-March/009499.html
    
    This patch reconciles libdrm with the the kernel change that Dave
    pushed this morning. It *supersedes* the previously sent patch (i.e.
    apply it to the master branch as it exists at the time of this writing,
    not as an incremental patch to the one sent previously).
    
    Regards,
    
    Ilija
    
    Signed-off-by: Ilija Hadzic <ihadzic@research.bell-labs.com>
    Signed-off-by: Alex Deucher <alexdeucher@gmail.com>

diff --git a/xf86drm.h b/xf86drm.h
index bf0d5df..20f4c78 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -296,12 +296,15 @@ typedef struct _drmTextureRegion {
 typedef enum {
     DRM_VBLANK_ABSOLUTE = 0x0,	/**< Wait for specific vblank sequence number */
     DRM_VBLANK_RELATIVE = 0x1,	/**< Wait for given number of vblanks */
+    /* bits 1-6 are reserved for high crtcs */
+    DRM_VBLANK_HIGH_CRTC_MASK = 0x0000003e,
     DRM_VBLANK_EVENT = 0x4000000,	/**< Send event instead of blocking */
     DRM_VBLANK_FLIP = 0x8000000,	/**< Scheduled buffer swap should flip */
     DRM_VBLANK_NEXTONMISS = 0x10000000,	/**< If missed, wait for next vblank */
     DRM_VBLANK_SECONDARY = 0x20000000,	/**< Secondary display controller */
     DRM_VBLANK_SIGNAL   = 0x40000000	/* Send signal instead of blocking */
 } drmVBlankSeqType;
+#define DRM_VBLANK_HIGH_CRTC_SHIFT 1
 
 typedef struct _drmVBlankReq {
 	drmVBlankSeqType type;

commit 5c6c6913d1260024e5d156db7973c9e46fe1ff03
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon Feb 21 11:27:19 2011 +1000

    Implement drmGetCap() to query device/driver capabilities
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/xf86drm.h b/xf86drm.h
index 9b89f56..bf0d5df 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -542,6 +542,7 @@ extern int drmOpenControl(int minor);
 extern int           drmClose(int fd);
 extern drmVersionPtr drmGetVersion(int fd);
 extern drmVersionPtr drmGetLibVersion(int fd);
+extern int           drmGetCap(int fd, uint64_t capability, uint64_t *value);
 extern void          drmFreeVersion(drmVersionPtr);
 extern int           drmGetMagic(int fd, drm_magic_t * magic);
 extern char          *drmGetBusid(int fd);

commit 14f5958f7fd9ebe8a772ea931feb044d2d5d967b
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Thu Dec 3 14:20:51 2009 -0800

    Bump event context structure version for page flipping

diff --git a/xf86drm.h b/xf86drm.h
index 89f1db1..9b89f56 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -693,7 +693,7 @@ extern void drmMsg(const char *format, ...);
 extern int drmSetMaster(int fd);
 extern int drmDropMaster(int fd);
 
-#define DRM_EVENT_CONTEXT_VERSION 1
+#define DRM_EVENT_CONTEXT_VERSION 2
 
 typedef struct _drmEventContext {
 

commit 53addc5d6ef7406d9fab5ea481cf68fa011870f1
Merge: db50f51 ee746a8
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Thu Dec 3 14:17:26 2009 -0800

    Merge branch 'pageflip' of git://people.freedesktop.org/~jbarnes/drm
    
    Conflicts:
    	include/drm/drm.h - RMFB had its signature changed to avoid uint32_t

commit 6f66de982ad6ee6967ec61a7399e600bdd9e5887
Author: Robert Noland <rnoland@2hip.net>
Date:   Wed Nov 25 15:09:24 2009 -0600

    Correctly set DRM_MAX_MINOR for all platforms.
    
    DRM_MAJOR is platform specific, but not used outside of xf86drm.c
    that I can find.

diff --git a/xf86drm.h b/xf86drm.h
index 9944d32..496d95d 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -39,6 +39,10 @@
 #include <stdint.h>
 #include <drm.h>
 
+#ifndef DRM_MAX_MINOR
+#define DRM_MAX_MINOR   16
+#endif
+
 #if defined(__linux__)
 
 #define DRM_IOCTL_NR(n)		_IOC_NR(n)
@@ -47,8 +51,6 @@
 #define DRM_IOC_WRITE		_IOC_WRITE
 #define DRM_IOC_READWRITE	_IOC_READ|_IOC_WRITE
 #define DRM_IOC(dir, group, nr, size) _IOC(dir, group, nr, size)
-#define DRM_MAJOR       226
-#define DRM_MAX_MINOR   15
 
 #else /* One of the *BSDs */
 

commit 9558f6377ffee680d6bec0808bc113b3139b0d5f
Author: Alex Deucher <alexdeucher@gmail.com>
Date:   Tue Nov 24 15:03:32 2009 -0500

    Add missing DRM_MAX_MINOR define
    
    lost in 500f5b524000ed5930301f4303744cb4c0a19b75
    
    Signed-off-by: Alex Deucher <alexdeucher@gmail.com>

diff --git a/xf86drm.h b/xf86drm.h
index f0dfb88..9944d32 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -48,6 +48,7 @@
 #define DRM_IOC_READWRITE	_IOC_READ|_IOC_WRITE
 #define DRM_IOC(dir, group, nr, size) _IOC(dir, group, nr, size)
 #define DRM_MAJOR       226
+#define DRM_MAX_MINOR   15
 
 #else /* One of the *BSDs */
 

commit 22d46669043d38fcd16efca773f5ed5693c0fb58
Author: Kristian Høgsberg <krh@bitplanet.net>
Date:   Mon Nov 23 20:51:34 2009 -0500

    Add drmGetDeviceNameFromFd function
    
    Determines the /dev filename of the drm fd argument.

diff --git a/xf86drm.h b/xf86drm.h
index cf7d132..f0dfb88 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -708,4 +708,6 @@ typedef struct _drmEventContext {
 
 extern int drmHandleEvent(int fd, drmEventContextPtr evctx);
 
+extern char *drmGetDeviceNameFromFd(int fd);
+
 #endif

commit 500f5b524000ed5930301f4303744cb4c0a19b75
Author: Kristian Høgsberg <krh@bitplanet.net>
Date:   Mon Nov 23 18:25:08 2009 -0500

    Fix build on *BSD
    
    This adds a minimal #ifdef clause to drm.h that we'll push upstream.
    Once that goes in we can share drm.h between linux, libdrm, and
    the bsd's.

diff --git a/xf86drm.h b/xf86drm.h
index 2cb9c9e..cf7d132 100644
--- a/xf86drm.h
+++ b/xf86drm.h
@@ -39,6 +39,28 @@
 #include <stdint.h>
 #include <drm.h>
 
+#if defined(__linux__)
+
+#define DRM_IOCTL_NR(n)		_IOC_NR(n)
+#define DRM_IOC_VOID		_IOC_NONE
+#define DRM_IOC_READ		_IOC_READ
+#define DRM_IOC_WRITE		_IOC_WRITE
+#define DRM_IOC_READWRITE	_IOC_READ|_IOC_WRITE
+#define DRM_IOC(dir, group, nr, size) _IOC(dir, group, nr, size)
+#define DRM_MAJOR       226
+
+#else /* One of the *BSDs */
+
+#include <sys/ioccom.h>
+#define DRM_IOCTL_NR(n)         ((n) & 0xff)
+#define DRM_IOC_VOID            IOC_VOID
+#define DRM_IOC_READ            IOC_OUT
+#define DRM_IOC_WRITE           IOC_IN
+#define DRM_IOC_READWRITE       IOC_INOUT
+#define DRM_IOC(dir, group, nr, size) _IOC(dir, group, nr, size)
+
+#endif
+
 				/* Defaults, if nothing set in xf86config */
 #define DRM_DEV_UID	 0
 #define DRM_DEV_GID	 0

commit 4f57abfe66091281c9f59c14e6ea27b524b55d5b
Author: Kristian Høgsberg <krh@bitplanet.net>
Date:   Tue Nov 17 11:14:54 2009 -0500

    Move libdrm/ up one level

diff --git a/xf86drm.h b/xf86drm.h
new file mode 100644
index 0000000..2cb9c9e
--- /dev/null
+++ b/xf86drm.h
@@ -0,0 +1,689 @@
+/**
+ * \file xf86drm.h 
+ * OS-independent header for DRM user-level library interface.
+ *
+ * \author Rickard E. (Rik) Faith <faith@valinux.com>
+ */
+ 
+/*
+ * Copyright 1999, 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _XF86DRM_H_
+#define _XF86DRM_H_
+
+#include <stdarg.h>
+#include <sys/types.h>
+#include <stdint.h>
+#include <drm.h>
+
+				/* Defaults, if nothing set in xf86config */
+#define DRM_DEV_UID	 0
+#define DRM_DEV_GID	 0
+/* Default /dev/dri directory permissions 0755 */
+#define DRM_DEV_DIRMODE	 	\
+	(S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH)
+#define DRM_DEV_MODE	 (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP)
+
+#define DRM_DIR_NAME  "/dev/dri"
+#define DRM_DEV_NAME  "%s/card%d"
+#define DRM_CONTROL_DEV_NAME  "%s/controlD%d"
+#define DRM_PROC_NAME "/proc/dri/" /* For backward Linux compatibility */
+
+#define DRM_ERR_NO_DEVICE  (-1001)
+#define DRM_ERR_NO_ACCESS  (-1002)
+#define DRM_ERR_NOT_ROOT   (-1003)
+#define DRM_ERR_INVALID    (-1004)
+#define DRM_ERR_NO_FD      (-1005)
+
+#define DRM_AGP_NO_HANDLE 0
+
+typedef unsigned int  drmSize,     *drmSizePtr;	    /**< For mapped regions */
+typedef void          *drmAddress, **drmAddressPtr; /**< For mapped regions */
+
+typedef struct _drmServerInfo {
+  int (*debug_print)(const char *format, va_list ap);
+  int (*load_module)(const char *name);
+  void (*get_perms)(gid_t *, mode_t *);
+} drmServerInfo, *drmServerInfoPtr;
+
+typedef struct drmHashEntry {
+    int      fd;
+    void     (*f)(int, void *, void *);
+    void     *tagTable;
+} drmHashEntry;
+
+extern int drmIoctl(int fd, unsigned long request, void *arg);
+extern void *drmGetHashTable(void);
+extern drmHashEntry *drmGetEntry(int fd);
+
+/**
+ * Driver version information.
+ *
+ * \sa drmGetVersion() and drmSetVersion().
+ */
+typedef struct _drmVersion {
+    int     version_major;        /**< Major version */
+    int     version_minor;        /**< Minor version */
+    int     version_patchlevel;   /**< Patch level */
+    int     name_len; 	          /**< Length of name buffer */
+    char    *name;	          /**< Name of driver */
+    int     date_len;             /**< Length of date buffer */
+    char    *date;                /**< User-space buffer to hold date */
+    int     desc_len;	          /**< Length of desc buffer */
+    char    *desc;                /**< User-space buffer to hold desc */
+} drmVersion, *drmVersionPtr;
+
+typedef struct _drmStats {
+    unsigned long count;	     /**< Number of data */
+    struct {
+	unsigned long value;	     /**< Value from kernel */
+	const char    *long_format;  /**< Suggested format for long_name */
+	const char    *long_name;    /**< Long name for value */
+	const char    *rate_format;  /**< Suggested format for rate_name */
+	const char    *rate_name;    /**< Short name for value per second */
+	int           isvalue;       /**< True if value (vs. counter) */
+	const char    *mult_names;   /**< Multiplier names (e.g., "KGM") */
+	int           mult;          /**< Multiplier value (e.g., 1024) */
+	int           verbose;       /**< Suggest only in verbose output */
+    } data[15];
+} drmStatsT;
+
+
+				/* All of these enums *MUST* match with the
+                                   kernel implementation -- so do *NOT*
+                                   change them!  (The drmlib implementation
+                                   will just copy the flags instead of
+                                   translating them.) */
+typedef enum {
+    DRM_FRAME_BUFFER    = 0,      /**< WC, no caching, no core dump */
+    DRM_REGISTERS       = 1,      /**< no caching, no core dump */
+    DRM_SHM             = 2,      /**< shared, cached */
+    DRM_AGP             = 3,	  /**< AGP/GART */
+    DRM_SCATTER_GATHER  = 4,	  /**< PCI scatter/gather */
+    DRM_CONSISTENT      = 5	  /**< PCI consistent */
+} drmMapType;
+
+typedef enum {
+    DRM_RESTRICTED      = 0x0001, /**< Cannot be mapped to client-virtual */
+    DRM_READ_ONLY       = 0x0002, /**< Read-only in client-virtual */
+    DRM_LOCKED          = 0x0004, /**< Physical pages locked */
+    DRM_KERNEL          = 0x0008, /**< Kernel requires access */
+    DRM_WRITE_COMBINING = 0x0010, /**< Use write-combining, if available */
+    DRM_CONTAINS_LOCK   = 0x0020, /**< SHM page that contains lock */
+    DRM_REMOVABLE	= 0x0040  /**< Removable mapping */
+} drmMapFlags;
+
+/**
+ * \warning These values *MUST* match drm.h
+ */
+typedef enum {
+    /** \name Flags for DMA buffer dispatch */
+    /*@{*/
+    DRM_DMA_BLOCK        = 0x01, /**< 
+				  * Block until buffer dispatched.
+				  * 
+				  * \note the buffer may not yet have been
+				  * processed by the hardware -- getting a
+				  * hardware lock with the hardware quiescent
+				  * will ensure that the buffer has been
+				  * processed.
+				  */
+    DRM_DMA_WHILE_LOCKED = 0x02, /**< Dispatch while lock held */
+    DRM_DMA_PRIORITY     = 0x04, /**< High priority dispatch */
+    /*@}*/
+
+    /** \name Flags for DMA buffer request */
+    /*@{*/
+    DRM_DMA_WAIT         = 0x10, /**< Wait for free buffers */
+    DRM_DMA_SMALLER_OK   = 0x20, /**< Smaller-than-requested buffers OK */
+    DRM_DMA_LARGER_OK    = 0x40  /**< Larger-than-requested buffers OK */
+    /*@}*/
+} drmDMAFlags;
+
+typedef enum {
+    DRM_PAGE_ALIGN       = 0x01,
+    DRM_AGP_BUFFER       = 0x02,
+    DRM_SG_BUFFER        = 0x04,
+    DRM_FB_BUFFER        = 0x08,
+    DRM_PCI_BUFFER_RO    = 0x10
+} drmBufDescFlags;
+
+typedef enum {
+    DRM_LOCK_READY      = 0x01, /**< Wait until hardware is ready for DMA */
+    DRM_LOCK_QUIESCENT  = 0x02, /**< Wait until hardware quiescent */
+    DRM_LOCK_FLUSH      = 0x04, /**< Flush this context's DMA queue first */
+    DRM_LOCK_FLUSH_ALL  = 0x08, /**< Flush all DMA queues first */
+				/* These *HALT* flags aren't supported yet
+                                   -- they will be used to support the
+                                   full-screen DGA-like mode. */
+    DRM_HALT_ALL_QUEUES = 0x10, /**< Halt all current and future queues */
+    DRM_HALT_CUR_QUEUES = 0x20  /**< Halt all current queues */
+} drmLockFlags;
+
+typedef enum {
+    DRM_CONTEXT_PRESERVED = 0x01, /**< This context is preserved and
+				     never swapped. */
+    DRM_CONTEXT_2DONLY    = 0x02  /**< This context is for 2D rendering only. */
+} drm_context_tFlags, *drm_context_tFlagsPtr;
+
+typedef struct _drmBufDesc {
+    int              count;	  /**< Number of buffers of this size */
+    int              size;	  /**< Size in bytes */
+    int              low_mark;	  /**< Low water mark */
+    int              high_mark;	  /**< High water mark */
+} drmBufDesc, *drmBufDescPtr;
+
+typedef struct _drmBufInfo {
+    int              count;	  /**< Number of buffers described in list */
+    drmBufDescPtr    list;	  /**< List of buffer descriptions */
+} drmBufInfo, *drmBufInfoPtr;
+
+typedef struct _drmBuf {
+    int              idx;	  /**< Index into the master buffer list */
+    int              total;	  /**< Buffer size */
+    int              used;	  /**< Amount of buffer in use (for DMA) */
+    drmAddress       address;	  /**< Address */
+} drmBuf, *drmBufPtr;
+
+/**
+ * Buffer mapping information.
+ *
+ * Used by drmMapBufs() and drmUnmapBufs() to store information about the
+ * mapped buffers.
+ */
+typedef struct _drmBufMap {
+    int              count;	  /**< Number of buffers mapped */
+    drmBufPtr        list;	  /**< Buffers */
+} drmBufMap, *drmBufMapPtr;
+
+typedef struct _drmLock {
+    volatile unsigned int lock;
+    char                      padding[60];
+    /* This is big enough for most current (and future?) architectures:
+       DEC Alpha:              32 bytes
+       Intel Merced:           ?
+       Intel P5/PPro/PII/PIII: 32 bytes
+       Intel StrongARM:        32 bytes
+       Intel i386/i486:        16 bytes
+       MIPS:                   32 bytes (?)
+       Motorola 68k:           16 bytes
+       Motorola PowerPC:       32 bytes
+       Sun SPARC:              32 bytes
+    */
+} drmLock, *drmLockPtr;
+
+/**
+ * Indices here refer to the offset into
+ * list in drmBufInfo
+ */
+typedef struct _drmDMAReq {
+    drm_context_t    context;  	  /**< Context handle */
+    int           send_count;     /**< Number of buffers to send */
+    int           *send_list;     /**< List of handles to buffers */
+    int           *send_sizes;    /**< Lengths of data to send, in bytes */
+    drmDMAFlags   flags;          /**< Flags */
+    int           request_count;  /**< Number of buffers requested */
+    int           request_size;	  /**< Desired size of buffers requested */
+    int           *request_list;  /**< Buffer information */
+    int           *request_sizes; /**< Minimum acceptable sizes */
+    int           granted_count;  /**< Number of buffers granted at this size */
+} drmDMAReq, *drmDMAReqPtr;
+
+typedef struct _drmRegion {
+    drm_handle_t     handle;
+    unsigned int  offset;
+    drmSize       size;
+    drmAddress    map;
+} drmRegion, *drmRegionPtr;
+
+typedef struct _drmTextureRegion {
+    unsigned char next;
+    unsigned char prev;
+    unsigned char in_use;
+    unsigned char padding;	/**< Explicitly pad this out */
+    unsigned int  age;
+} drmTextureRegion, *drmTextureRegionPtr;
+
+
+typedef enum {
+    DRM_VBLANK_ABSOLUTE = 0x0,	/**< Wait for specific vblank sequence number */
+    DRM_VBLANK_RELATIVE = 0x1,	/**< Wait for given number of vblanks */
+    DRM_VBLANK_EVENT = 0x4000000,	/**< Send event instead of blocking */
+    DRM_VBLANK_FLIP = 0x8000000,	/**< Scheduled buffer swap should flip */
+    DRM_VBLANK_NEXTONMISS = 0x10000000,	/**< If missed, wait for next vblank */
+    DRM_VBLANK_SECONDARY = 0x20000000,	/**< Secondary display controller */
+    DRM_VBLANK_SIGNAL   = 0x40000000	/* Send signal instead of blocking */
+} drmVBlankSeqType;
+
+typedef struct _drmVBlankReq {
+	drmVBlankSeqType type;
+	unsigned int sequence;
+	unsigned long signal;
+} drmVBlankReq, *drmVBlankReqPtr;
+
+typedef struct _drmVBlankReply {
+	drmVBlankSeqType type;
+	unsigned int sequence;
+	long tval_sec;
+	long tval_usec;
+} drmVBlankReply, *drmVBlankReplyPtr;
+
+typedef union _drmVBlank {
+	drmVBlankReq request;
+	drmVBlankReply reply;
+} drmVBlank, *drmVBlankPtr;
+
+typedef struct _drmSetVersion {
+	int drm_di_major;
+	int drm_di_minor;
+	int drm_dd_major;
+	int drm_dd_minor;
+} drmSetVersion, *drmSetVersionPtr;
+
+#define __drm_dummy_lock(lock) (*(__volatile__ unsigned int *)lock)
+
+#define DRM_LOCK_HELD  0x80000000U /**< Hardware lock is held */
+#define DRM_LOCK_CONT  0x40000000U /**< Hardware lock is contended */
+
+#if defined(__GNUC__) && (__GNUC__ >= 2)
+# if defined(__i386) || defined(__AMD64__) || defined(__x86_64__) || defined(__amd64__)
+				/* Reflect changes here to drmP.h */
+#define DRM_CAS(lock,old,new,__ret)                                    \
+	do {                                                           \
+                int __dummy;	/* Can't mark eax as clobbered */      \
+		__asm__ __volatile__(                                  \
+			"lock ; cmpxchg %4,%1\n\t"                     \
+                        "setnz %0"                                     \
+			: "=d" (__ret),                                \
+   			  "=m" (__drm_dummy_lock(lock)),               \
+                          "=a" (__dummy)                               \
+			: "2" (old),                                   \
+			  "r" (new));                                  \
+	} while (0)
+
+#elif defined(__alpha__)
+
+#define	DRM_CAS(lock, old, new, ret)		\
+	do {					\
+		int tmp, old32;			\
+		__asm__ __volatile__(		\
+		"	addl	$31, %5, %3\n"	\
+		"1:	ldl_l	%0, %2\n"	\
+		"	cmpeq	%0, %3, %1\n"	\
+		"	beq	%1, 2f\n"	\
+		"	mov	%4, %0\n"	\
+		"	stl_c	%0, %2\n"	\
+		"	beq	%0, 3f\n"	\
+		"	mb\n"			\
+		"2:	cmpeq	%1, 0, %1\n"	\
+		".subsection 2\n"		\
+		"3:	br	1b\n"		\
+		".previous"			\
+		: "=&r"(tmp), "=&r"(ret),	\
+		  "=m"(__drm_dummy_lock(lock)),	\
+		  "=&r"(old32)			\
+		: "r"(new), "r"(old)		\
+		: "memory");			\
+	} while (0)
+
+#elif defined(__sparc__)
+
+#define DRM_CAS(lock,old,new,__ret)				\
+do {	register unsigned int __old __asm("o0");		\
+	register unsigned int __new __asm("o1");		\
+	register volatile unsigned int *__lock __asm("o2");	\
+	__old = old;						\
+	__new = new;						\
+	__lock = (volatile unsigned int *)lock;			\
+	__asm__ __volatile__(					\
+		/*"cas [%2], %3, %0"*/				\
+		".word 0xd3e29008\n\t"				\
+		/*"membar #StoreStore | #StoreLoad"*/		\
+		".word 0x8143e00a"				\
+		: "=&r" (__new)					\
+		: "0" (__new),					\
+		  "r" (__lock),					\
+		  "r" (__old)					\
+		: "memory");					\
+	__ret = (__new != __old);				\
+} while(0)
+
+#elif defined(__ia64__)
+
+#ifdef __INTEL_COMPILER
+/* this currently generates bad code (missing stop bits)... */
+#include <ia64intrin.h>
+
+#define DRM_CAS(lock,old,new,__ret)					      \
+	do {								      \
+		unsigned long __result, __old = (old) & 0xffffffff;		\
+		__mf();							      	\
+		__result = _InterlockedCompareExchange_acq(&__drm_dummy_lock(lock), (new), __old);\
+		__ret = (__result) != (__old);					\
+/*		__ret = (__sync_val_compare_and_swap(&__drm_dummy_lock(lock), \
+						     (old), (new))	      \
+			 != (old));					      */\
+	} while (0)
+
+#else
+#define DRM_CAS(lock,old,new,__ret)					  \
+	do {								  \
+		unsigned int __result, __old = (old);			  \
+		__asm__ __volatile__(					  \
+			"mf\n"						  \
+			"mov ar.ccv=%2\n"				  \
+			";;\n"						  \
+			"cmpxchg4.acq %0=%1,%3,ar.ccv"			  \
+			: "=r" (__result), "=m" (__drm_dummy_lock(lock))  \
+			: "r" ((unsigned long)__old), "r" (new)			  \
+			: "memory");					  \
+		__ret = (__result) != (__old);				  \
+	} while (0)
+
+#endif
+
+#elif defined(__powerpc__)
+
+#define DRM_CAS(lock,old,new,__ret)			\
+	do {						\
+		__asm__ __volatile__(			\
+			"sync;"				\
+			"0:    lwarx %0,0,%1;"		\
+			"      xor. %0,%3,%0;"		\
+			"      bne 1f;"			\
+			"      stwcx. %2,0,%1;"		\
+			"      bne- 0b;"		\
+			"1:    "			\
+			"sync;"				\
+		: "=&r"(__ret)				\
+		: "r"(lock), "r"(new), "r"(old)		\
+		: "cr0", "memory");			\
+	} while (0)
+
+#endif /* architecture */
+#endif /* __GNUC__ >= 2 */
+
+#ifndef DRM_CAS
+#define DRM_CAS(lock,old,new,ret) do { ret=1; } while (0) /* FAST LOCK FAILS */
+#endif
+
+#if defined(__alpha__)
+#define DRM_CAS_RESULT(_result)		long _result
+#elif defined(__powerpc__)
+#define DRM_CAS_RESULT(_result)		int _result
+#else
+#define DRM_CAS_RESULT(_result)		char _result
+#endif
+
+#define DRM_LIGHT_LOCK(fd,lock,context)                                \
+	do {                                                           \
+                DRM_CAS_RESULT(__ret);                                 \
+		DRM_CAS(lock,context,DRM_LOCK_HELD|context,__ret);     \
+                if (__ret) drmGetLock(fd,context,0);                   \
+        } while(0)
+
+				/* This one counts fast locks -- for
+                                   benchmarking only. */
+#define DRM_LIGHT_LOCK_COUNT(fd,lock,context,count)                    \
+	do {                                                           \
+                DRM_CAS_RESULT(__ret);                                 \
+		DRM_CAS(lock,context,DRM_LOCK_HELD|context,__ret);     \
+                if (__ret) drmGetLock(fd,context,0);                   \
+                else       ++count;                                    \
+        } while(0)
+
+#define DRM_LOCK(fd,lock,context,flags)                                \
+	do {                                                           \
+		if (flags) drmGetLock(fd,context,flags);               \
+		else       DRM_LIGHT_LOCK(fd,lock,context);            \
+	} while(0)
+
+#define DRM_UNLOCK(fd,lock,context)                                    \
+	do {                                                           \
+                DRM_CAS_RESULT(__ret);                                 \
+		DRM_CAS(lock,DRM_LOCK_HELD|context,context,__ret);     \
+                if (__ret) drmUnlock(fd,context);                      \
+        } while(0)
+
+				/* Simple spin locks */
+#define DRM_SPINLOCK(spin,val)                                         \
+	do {                                                           \
+            DRM_CAS_RESULT(__ret);                                     \
+	    do {                                                       \
+		DRM_CAS(spin,0,val,__ret);                             \
+		if (__ret) while ((spin)->lock);                       \
+	    } while (__ret);                                           \
+	} while(0)
+
+#define DRM_SPINLOCK_TAKE(spin,val)                                    \
+	do {                                                           \
+            DRM_CAS_RESULT(__ret);                                     \
+            int  cur;                                                  \
+	    do {                                                       \
+                cur = (*spin).lock;                                    \
+		DRM_CAS(spin,cur,val,__ret);                           \
+	    } while (__ret);                                           \
+	} while(0)
+
+#define DRM_SPINLOCK_COUNT(spin,val,count,__ret)                       \
+	do {                                                           \
+            int  __i;                                                  \
+            __ret = 1;                                                 \
+            for (__i = 0; __ret && __i < count; __i++) {               \
+		DRM_CAS(spin,0,val,__ret);                             \
+		if (__ret) for (;__i < count && (spin)->lock; __i++);  \
+	    }                                                          \
+	} while(0)
+
+#define DRM_SPINUNLOCK(spin,val)                                       \
+	do {                                                           \
+            DRM_CAS_RESULT(__ret);                                     \
+            if ((*spin).lock == val) { /* else server stole lock */    \
+	        do {                                                   \
+		    DRM_CAS(spin,val,0,__ret);                         \
+	        } while (__ret);                                       \
+            }                                                          \
+	} while(0)
+
+
+
+/* General user-level programmer's API: unprivileged */
+extern int           drmAvailable(void);
+extern int           drmOpen(const char *name, const char *busid);
+extern int drmOpenControl(int minor);
+extern int           drmClose(int fd);
+extern drmVersionPtr drmGetVersion(int fd);
+extern drmVersionPtr drmGetLibVersion(int fd);
+extern void          drmFreeVersion(drmVersionPtr);
+extern int           drmGetMagic(int fd, drm_magic_t * magic);
+extern char          *drmGetBusid(int fd);
+extern int           drmGetInterruptFromBusID(int fd, int busnum, int devnum,
+					      int funcnum);
+extern int           drmGetMap(int fd, int idx, drm_handle_t *offset,
+			       drmSize *size, drmMapType *type,
+			       drmMapFlags *flags, drm_handle_t *handle,
+			       int *mtrr);
+extern int           drmGetClient(int fd, int idx, int *auth, int *pid,
+				  int *uid, unsigned long *magic,
+				  unsigned long *iocs);
+extern int           drmGetStats(int fd, drmStatsT *stats);
+extern int           drmSetInterfaceVersion(int fd, drmSetVersion *version);
+extern int           drmCommandNone(int fd, unsigned long drmCommandIndex);
+extern int           drmCommandRead(int fd, unsigned long drmCommandIndex,
+                                    void *data, unsigned long size);
+extern int           drmCommandWrite(int fd, unsigned long drmCommandIndex,
+                                     void *data, unsigned long size);
+extern int           drmCommandWriteRead(int fd, unsigned long drmCommandIndex,
+                                         void *data, unsigned long size);
+
+/* General user-level programmer's API: X server (root) only  */
+extern void          drmFreeBusid(const char *busid);
+extern int           drmSetBusid(int fd, const char *busid);
+extern int           drmAuthMagic(int fd, drm_magic_t magic);
+extern int           drmAddMap(int fd,
+			       drm_handle_t offset,
+			       drmSize size,
+			       drmMapType type,
+			       drmMapFlags flags,
+			       drm_handle_t * handle);
+extern int	     drmRmMap(int fd, drm_handle_t handle);
+extern int	     drmAddContextPrivateMapping(int fd, drm_context_t ctx_id,
+						 drm_handle_t handle);
+
+extern int           drmAddBufs(int fd, int count, int size,
+				drmBufDescFlags flags,
+				int agp_offset);
+extern int           drmMarkBufs(int fd, double low, double high);
+extern int           drmCreateContext(int fd, drm_context_t * handle);
+extern int           drmSetContextFlags(int fd, drm_context_t context,
+					drm_context_tFlags flags);
+extern int           drmGetContextFlags(int fd, drm_context_t context,
+					drm_context_tFlagsPtr flags);
+extern int           drmAddContextTag(int fd, drm_context_t context, void *tag);
+extern int           drmDelContextTag(int fd, drm_context_t context);
+extern void          *drmGetContextTag(int fd, drm_context_t context);
+extern drm_context_t * drmGetReservedContextList(int fd, int *count);
+extern void          drmFreeReservedContextList(drm_context_t *);
+extern int           drmSwitchToContext(int fd, drm_context_t context);
+extern int           drmDestroyContext(int fd, drm_context_t handle);
+extern int           drmCreateDrawable(int fd, drm_drawable_t * handle);
+extern int           drmDestroyDrawable(int fd, drm_drawable_t handle);
+extern int           drmUpdateDrawableInfo(int fd, drm_drawable_t handle,
+					   drm_drawable_info_type_t type,
+					   unsigned int num, void *data);
+extern int           drmCtlInstHandler(int fd, int irq);
+extern int           drmCtlUninstHandler(int fd);
+
+/* General user-level programmer's API: authenticated client and/or X */
+extern int           drmMap(int fd,
+			    drm_handle_t handle,
+			    drmSize size,
+			    drmAddressPtr address);
+extern int           drmUnmap(drmAddress address, drmSize size);
+extern drmBufInfoPtr drmGetBufInfo(int fd);
+extern drmBufMapPtr  drmMapBufs(int fd);
+extern int           drmUnmapBufs(drmBufMapPtr bufs);
+extern int           drmDMA(int fd, drmDMAReqPtr request);
+extern int           drmFreeBufs(int fd, int count, int *list);
+extern int           drmGetLock(int fd,
+			        drm_context_t context,
+			        drmLockFlags flags);
+extern int           drmUnlock(int fd, drm_context_t context);
+extern int           drmFinish(int fd, int context, drmLockFlags flags);
+extern int	     drmGetContextPrivateMapping(int fd, drm_context_t ctx_id, 
+						 drm_handle_t * handle);
+
+/* AGP/GART support: X server (root) only */
+extern int           drmAgpAcquire(int fd);
+extern int           drmAgpRelease(int fd);
+extern int           drmAgpEnable(int fd, unsigned long mode);
+extern int           drmAgpAlloc(int fd, unsigned long size,
+				 unsigned long type, unsigned long *address,
+				 drm_handle_t *handle);
+extern int           drmAgpFree(int fd, drm_handle_t handle);
+extern int 	     drmAgpBind(int fd, drm_handle_t handle,
+				unsigned long offset);
+extern int           drmAgpUnbind(int fd, drm_handle_t handle);
+
+/* AGP/GART info: authenticated client and/or X */
+extern int           drmAgpVersionMajor(int fd);
+extern int           drmAgpVersionMinor(int fd);
+extern unsigned long drmAgpGetMode(int fd);
+extern unsigned long drmAgpBase(int fd); /* Physical location */
+extern unsigned long drmAgpSize(int fd); /* Bytes */
+extern unsigned long drmAgpMemoryUsed(int fd);
+extern unsigned long drmAgpMemoryAvail(int fd);
+extern unsigned int  drmAgpVendorId(int fd);
+extern unsigned int  drmAgpDeviceId(int fd);
+
+/* PCI scatter/gather support: X server (root) only */
+extern int           drmScatterGatherAlloc(int fd, unsigned long size,
+					   drm_handle_t *handle);
+extern int           drmScatterGatherFree(int fd, drm_handle_t handle);
+
+extern int           drmWaitVBlank(int fd, drmVBlankPtr vbl);
+
+/* Support routines */
+extern void          drmSetServerInfo(drmServerInfoPtr info);
+extern int           drmError(int err, const char *label);
+extern void          *drmMalloc(int size);
+extern void          drmFree(void *pt);
+
+/* Hash table routines */
+extern void *drmHashCreate(void);
+extern int  drmHashDestroy(void *t);
+extern int  drmHashLookup(void *t, unsigned long key, void **value);
+extern int  drmHashInsert(void *t, unsigned long key, void *value);
+extern int  drmHashDelete(void *t, unsigned long key);
+extern int  drmHashFirst(void *t, unsigned long *key, void **value);
+extern int  drmHashNext(void *t, unsigned long *key, void **value);
+
+/* PRNG routines */
+extern void          *drmRandomCreate(unsigned long seed);
+extern int           drmRandomDestroy(void *state);
+extern unsigned long drmRandom(void *state);
+extern double        drmRandomDouble(void *state);
+
+/* Skip list routines */
+
+extern void *drmSLCreate(void);
+extern int  drmSLDestroy(void *l);
+extern int  drmSLLookup(void *l, unsigned long key, void **value);
+extern int  drmSLInsert(void *l, unsigned long key, void *value);
+extern int  drmSLDelete(void *l, unsigned long key);
+extern int  drmSLNext(void *l, unsigned long *key, void **value);
+extern int  drmSLFirst(void *l, unsigned long *key, void **value);
+extern void drmSLDump(void *l);
+extern int  drmSLLookupNeighbors(void *l, unsigned long key,
+				 unsigned long *prev_key, void **prev_value,
+				 unsigned long *next_key, void **next_value);
+
+extern int drmOpenOnce(void *unused, const char *BusID, int *newlyopened);
+extern void drmCloseOnce(int fd);
+extern void drmMsg(const char *format, ...);
+
+extern int drmSetMaster(int fd);
+extern int drmDropMaster(int fd);
+
+#define DRM_EVENT_CONTEXT_VERSION 1
+
+typedef struct _drmEventContext {
+
+	/* This struct is versioned so we can add more pointers if we
+	 * add more events. */
+	int version;
+
+	void (*vblank_handler)(int fd,
+			       unsigned int sequence, 
+			       unsigned int tv_sec,
+			       unsigned int tv_usec,
+			       void *user_data);
+
+} drmEventContext, *drmEventContextPtr;
+
+extern int drmHandleEvent(int fd, drmEventContextPtr evctx);
+
+#endif
